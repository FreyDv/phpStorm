<html lang="en"><head><meta charset="utf-8"><style>
        body {background: #1C1818FF; /* Цвет фона */color: #FFCC00FF; /* Цвет текста */}
        iframe { width:100%; height:1000px;}
    </style>
    <title>21 Урок</title></head><body></body></html>
<?php

//<editor-fold desc="date — Форматирует вывод системной даты/времени">
//date( string $format, int|null $timestamp = null) : string
//Возвращает строку, отформатированную в соответствии с указанным шаблоном format. Используется метка времени, заданная
// аргументом timestamp, или текущее системное время, если timestamp не задан. Таким образом, timestamp является
// необязательным и по умолчанию равензначению, возвращаемому функцией time().
$d =date("d.m.y h:i:s");
//</editor-fold>
//<editor-fold desc="date_default_timezone_get,date_default_timezone_set">
//date_default_timezone_get() : string
//date_default_timezone_set — Устанавливает временную зону по умолчанию для всех функцийдаты/времени в скрипте
//date_default_timezone_set( string $timezoneId) : bool
//date_default_timezone_set() устанавливает временнуюзону по умолчанию для всех функций даты/времени в скрипте.
//Функция пытается получить временную зону по умолчанию по порядкуследующими способами:
//◦ Чтение настройки временной зоны с помощью функции date_default_timezone_set() (если применимо)
//◦ Только до версии PHP 5.4.0: чтениепеременной окружения TZ (если она непуста)
//◦ Чтение значения ini-настройки date.timezone (если задана)

//В файле php.ini по запросу date.timezone можно выставить часовой пояс. Или с помошью функции date_default_timezone_set()
$d = date_default_timezone_get();
date_default_timezone_set("Europe/Kiev");
$d = date_default_timezone_get();
//</editor-fold>
//<editor-fold desc="time — Возвращает текущую метку системного времени Unix">
//time() : int
//Возвращает количество секунд, прошедших с начала эпохи Unix(1 января 1970 00:00:00 GMT) до текущего времени.
$d = time(); // количество секунд от 1 января 1970 00:00:00 GMT
// к текушей дате в секундах добавляю 60секунд умноженые на 60 минут на 24 часа и на 365 дней  что должно показать дату
//ровно через год
$d = date("y-m-d h:i:s",time()+60*60*24*365);
//аналгоичная ситуация только год назад
$d = date("y-m-d h:i:s",time()-60*60*24*365);
//</editor-fold>
//<editor-fold desc="getdate — Возвращает информацию о дате/времени">

//getdate( int|null $timestamp = null) : array
//Возвращает ассоциативный массив (array), содержащийинформацию о дате,
// представленной меткой времени timestamp или текущим системным временем, если timestamp не был передан или null.
$d = getdate();
//</editor-fold>
//<editor-fold desc="strtotime — Преобразует текстовое представление даты на английском языке в метку времени Unix">
//strtotime( string $datetime, int|null $baseTimestamp = null) : int|false
//Первым параметром функции должна быть строка с датой на английском языке, котораябудет преобразована в метку времени
//Unix (количество секунд, прошедших с 1 января 1970 года 00:00:00 UTC) относительно метки времени, переданной в
//baseTimestamp, или текущего времени, если аргумент baseTimestamp опущен
//+1 день к текушей дате
$d = strtotime("+1 day", 1622122560);
if ($d === false) {
    echo "<pre>";
    print_r("EROR");
    echo "</pre><br>";
} else {
    $d = date("d.m.Y h:i:s", $d);
}
//+1 неделя к текушей дате
$d = strtotime("+1 week", 1622122560);
if ($d === false) {
    echo "<pre>";
    print_r("EROR");
    echo "</pre><br>";
} else {
    $d = date("d.m.Y h:i:s", $d);
}
//+1 неделя 2 дня 4 часа и 2 секунды к текушей дате
$d = strtotime("+1 week 2 days 4 hours 2 seconds");
if ($d === false) {
    echo "<pre>";
    print_r("EROR");
    echo "</pre><br>";
} else {
    $d = date("d.m.Y h:i:s", $d);
}
//Следуюший понидельник от текушей дате
$d = strtotime("next Monday");
if ($d === false) {
    echo "<pre>";
    print_r("EROR");
    echo "</pre><br>";
} else {
    $d = date("d.m.Y h:i:s", $d);
}
//Предидуший четверг от текушей дате
$d = strtotime("last Thursday");
if ($d === false) {
    echo "<pre>";
    print_r("EROR");
    echo "</pre><br>";
} else {
    $d = date("d.m.Y h:i:s", $d);
}
//Просто дата
$d = strtotime("10 September 2000");
if ($d === false) {
    echo "<pre>";
    print_r("EROR");
    echo "</pre><br>";
} else {
    $d = date("d.m.Y h:i:s", $d);
}
//текушая дата
$d = strtotime("now");
if ($d === false) {
    echo "<pre>";
    print_r("EROR");
    echo "</pre><br>";
} else {
    $d = date("d.m.Y h:i:s", $d);
}
//</editor-fold>
//<editor-fold desc="mktime — Возвращает метку времени Unix для заданной даты">
//mktime( int $hour, int|null $minute = null, int|null $second = null, int|null $month = null, int|null $day = null, int|null $year = null) : int|false
//Функция возвращает метку времени Unix, соответствующую дате и времени, переданных вкачестве аргументов. Метка времени -
// это целое число, равное разнице в секундах между заданнойдатой/временем и началом эпохи Unix (1 января 1970 00:00:00 GMT).
//Аргументы могут быть опущены в порядке справа налево. В этом случае их значения поумолчанию равны соответствующим
// компонентам локальной даты/времени.
//Список параметров
//***hour-Количество часов, прошедших с начала дня, указанного параметрами month, day и year. Отрицательные значения
// определяют часы до полуночи указанногодня. Значения больше 23 определяют соответствующий часследующего дня (или дней).
//***minute-Количество минут, прошедших от начала часа, указанного параметром hour. Отрицательные значения определяют минуты
// предыдущего часа. Значения больше 59 определяют соответствующие минуты следующего часа (или часов).
//***second-Количество секунд, прошедших от начала минуты, указанной параметром minute. Отрицательные значения определяют
// секунды изпредыдущей минуты. Значения больше 59 определяют соответствующие секундыследующей минуты (или минут).
//***month-Количество месяцев, прошедших с конца предыдущего года. Значения от 1 до 12 определяют нормальные обычные
// календарные месяцы года. Значения меньше 1 (включая отрицательные значения) определяют месяца предыдущегогода в обратном
// порядке, то есть 0 будет декабрём, -1 - ноябрём и т.д. Значения больше 12 определяют соответствующий месяц в следующем году (или годах).
//***day-Количество дней, прошедших с конца предыдущего месяца. Значения от 1 до 28, 29, 30 или 31 (в зависимости от месяца)
// определяют нормальные днисоответствующего месяца. Значения меньше 1 (включая отрицательные значения) определяют дни
// предыдущего месяца, таким образом, 0 является последним днёмпредыдущего месяца, -1 - предпоследним днём предыдущего
// месяца и т.д. Значения больше количества дней соответствующего месяца определяютсоответствующий день следующего месяца (или месяцев).
//***year-Номер года, может быть указан двумя или четырьмя цифрами, причём значения между 0-69 будут трактованы как 2000-2069,
// а между 70-100 - как 1970-2000. На тех системах, где time_t является 32-битным знаковым целым (наиболее распространённый
// вариант насегодня), корректный диапазон для параметра year содержитдаты где-то между 1901 и 2038. Однако, до версии PHP 5.1.0,
// на некоторых системахэтот диапазон был ограничен датами между 1970 и 2038 (например, Windows).
//***isDST-Данный параметр может быть установлен в 1, если заданной дате соответствует летнеевремя (DST), 0 - в противном случае,
// или -1 (значение по умолчанию), если неизвестно, действует ли летнее время на заданную дату. В последнем случае PHP пытаетсяопределить
// это самостоятельно. Это может привести к неожиданному результату (который, тем не менее, не будет неверным). Некоторые даты могут быть
// неверными, если летнеевремя применимо к системе, на которой запущен PHP, или параметр isDST установлен в 1. Если переход на летнее
// времяпроисходит, например, в 2:00, все даты между 2:00 и 3:00 станут некорректными и mktime() вернёт неопределённое
// (обычно отрицательное) значение. Некоторые системы (например, Solaris 8) осуществляют переход на летнее время вполночь,
// так что время 0:30 дня, когда был осуществлён переход на летнее время будетобрабатываться как 23:30 предыдущего дня.
// Текушая дата через mktime
$d = mktime(date("h"),date("i"),date("s"),date("m"),date("d"),date("Y"));
$d = mktime(5,50,55,12,15,2025); // выдуманая дата
if ($d === false) {
    echo "<pre>";
    print_r("EROR");
    echo "</pre><br>";
} else {
    $d = date("d.m.Y h:i:s", $d);
}

//</editor-fold>
//<editor-fold desc="date_create — Псевдоним DateTime::__construct()">
//Объектно-ориентированный стиль:
//public DateTime::__construct( string $datetime = "now", DateTimeZone|null $timezone = null)
//Процедурный стиль:
//date_create( string $datetime = "now", DateTimeZone|null $timezone = null) : DateTime|false
//Создаёт и возвращает новый экземпляр класса DateTime.
//Список параметров:
//***datetime
//Строка даты/времени. Объяснение корректных форматов дано в разделе Форматы даты и времени.
//Если используется аргумент $timezone, тодля получения текущего времени в новом объекте достаточнопередать "now" в
//качестве этого аргумента.
//***timezone
//Объект класса DateTimeZone, представляющийвременную зону параметра $datetime.
//Если аргумент $timezone не задан или null, будет использована текущая временная зона.
//Замечание:
//Значение аргумента $timezone равно каки текущая временная зона не будут учитываться, если в качествеаргумента $datetime
//передаётся метка времени UNIX (например @946684800) или время, в которомвременная зона уже содержится
//(например 2010-01-28T15:00:00+02:00).
$date = date_create('2021-05-27');
$date = date_create("now");
//</editor-fold>
//<editor-fold desc="date_add — Добавляет заданное количество дней, месяцев, лет, часов, минут исекунд к объекту DateTime">
{
//date_add( DateTime $object, DateInterval $interval) : DateTime
//Прибавляет заданный объект DateInterval к объекту DateTime.
//object:
//Только для процедурного стиля: Объект DateTime, возвращаемый date_create(). Функция изменяет этот объект.
//interval:
//Объект класса DateInterval
// P-Период
// 1Y- Один год
// 1M- Один месяц
// 1W- Одна неделя
// 1D- Один день
// T-  Временной период
// 1H- Один час
// 1M- Одна минута
// 1S- Одна секунда
$inter = new DateInterval('P1Y1M1W1DT1H1M1S');
$datar = date_add($date,$inter);
}
//</editor-fold>
//<editor-fold desc="Description">
{

}
//</editor-fold>
//<editor-fold desc="Description">
{

}
//</editor-fold>
//<editor-fold desc="Description">
{

}
//</editor-fold>
//<editor-fold desc="Description">
{

}
//</editor-fold>
//<editor-fold desc="microtime — Возвращает текущую метку времени Unix с микросекундами">
//microtime( bool $as_float = false) : string|float
//Функция microtime() возвращает текущую меткувремени Unix с микросекундами. Эта функция доступна
// только наоперационных системах, в которых есть системный вызов gettimeofday().
//Для измерения производительности рекомендуется использовать hrtime().
//as_float:
//Если указано и установлено в true, microtime() возвратит число с плавающей точкой (float) вместостроки (string),
// как описано в разделе возвращаемых значений ниже
$s = microtime(true);
//</editor-fold>
//<editor-fold desc="Code for calculate rime successful finished cod">
{
    /*
    $s = microtime(true);
    $e =0;
    $x= 1000;// не вводить больше милиарда (x< 1 000 000 000 )
    for ($i=0;$i<$x;$i++){
        if($i>$x-2) echo "Старт испытаний: ".$s."<br>Все я был заебан в ".$x." раз за: <br>";
    }
    $e = microtime(true);
    echo $e-$s;
   */
}
//</editor-fold>


echo "<pre>";
print_r($inter);
echo "<br>";
var_dump($datar);
echo $datar;
echo "</pre><br>";



